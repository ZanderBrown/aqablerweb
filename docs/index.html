<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width,initial-scale=1"><meta content="text/html;charset=utf-8" http-equiv="Content-Type"><meta name="google-site-verification" content="tgBZZbTjf9GP9Q1bAsNqfPHnBkD4PqXiGjX1EOEJA0Y"><meta name="msvalidate.01" content="30F4275ADACE27E6768CA7777F3DD6D6"><link rel="stylesheet" href="style.css"><link rel="canonical" href="https://zanderbrown.github.io/aqablerweb/"><meta name="description" content="Play with AQA Assembly code"><title>Aqabler</title><script src="index.js" defer="defer"></script><link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png"><link rel="manifest" href="./site.webmanifest"><link rel="mask-icon" href="./safari-pinned-tab.svg" color="#3030d8"><link rel="shortcut icon" href="./favicon.ico"><meta name="apple-mobile-web-app-title" content="Aqabler"><meta name="application-name" content="Aqabler"><meta name="msapplication-TileColor" content="#3030d8"><meta name="msapplication-TileImage" content="./mstile-144x144.png"><meta name="msapplication-config" content="./browserconfig.xml"><meta name="theme-color" content="#3030d8"></head><body><header><img src="logo.svg" alt="Logo"><h1>Aqabler</h1></header><div class="card program"><div class="title"><h2>Program</h2><button id="run">Run</button></div><textarea id="source" spellcheck="false" aria-label="Source Code">MOV R0, #42</textarea></div><section class="main"><div class="card" id="result">Please Wait...</div><div class="hack01"></div><section class="card registers hidden"><div class="title"><h2>Registers</h2></div><div id="registers"></div><div class="footer"><select id="reg-mode"><option value="unsigned" selected="selected">Unsigned</option><option value="signed">Signed</option></select></div></section><div class="hack01"></div><section class="card"><div class="title"><h2>Aqabler</h2></div><div class="content"><p>Aqabler "a-qab-ler" is an implementation of the AQA Assembly Language Instruction as used in the 7516 & 7517 AS/A-Level specification</p><p>The implementation follows <a href="https://filestore.aqa.org.uk/resources/computing/AQA-75162-75172-ALI.PDF">AQA's spec</a> with extra information taken from past papers</p><h3>Past Papers</h3><ul><li><a href="https://filestore.aqa.org.uk/sample-papers-and-mark-schemes/2017/june/AQA-75172-QP-JUN17.PDF">2017 A-Level Paper 2 (Question 5)</a></li><li><a href="https://filestore.aqa.org.uk/sample-papers-and-mark-schemes/2017/june/AQA-75162-QP-JUN17.PDF">2017 AS Paper 2 (Question 7)</a></li><li><a href="https://filestore.aqa.org.uk/sample-papers-and-mark-schemes/2016/june/AQA-75162-QP-JUN16.PDF">2016 AS Paper 2 (Question 4)</a></li><li><a href="https://filestore.aqa.org.uk/resources/computing/AQA-75172-SQP.PDF">Specimen A-Level Paper 2 (Question 6)</a></li><li><a href="https://filestore.aqa.org.uk/resources/computing/AQA-75162-SQP.PDF">Specimen AS Paper 2 (Question 6)</a></li></ul><h3>Assumptions</h3><p>Registers are assumed to be 32bit as <a href="https://www.aqa.org.uk/resources/computer-science-and-it/as-and-a-level/computer-science-7516-7517/plan/guidance-on-areas-of-concern">it is stated that</a> the language "is based on the ARM Assembly Language used by the Raspberry Pi."</p><p></p></div></section></section><main class="reference"><div class="card"><div class="title"><h2>Reference</h2></div><div class="page-title hidden"><div class="back" tabindex="0">←</div><div class="title"><h2>Reference</h2></div></div><div class="overview"><p class="heading" tabindex="0">Memory</p><ul><li tabindex="0">LDR</li><li tabindex="0">STR</li><li tabindex="0">MOV</li></ul><p class="heading" tabindex="0">Arithmetic</p><ul><li tabindex="0">ADD</li><li tabindex="0">SUB</li></ul><p class="heading" tabindex="0">Branching</p><ul><li tabindex="0">Branching Overview</li><li tabindex="0">CMP</li><li tabindex="0">B</li><li tabindex="0">BEQ</li><li tabindex="0">BNE</li><li tabindex="0">BGT</li><li tabindex="0">BLT</li></ul><p class="heading" tabindex="0">Bitwise</p><ul><li tabindex="0">Bitwise Overview</li><li tabindex="0">AND</li><li tabindex="0">ORR</li><li tabindex="0">EOR</li><li tabindex="0">MVN</li><li tabindex="0">LSL</li><li tabindex="0">LSR</li></ul><p class="heading" tabindex="0">Other</p><ul><li tabindex="0">HALT</li></ul></div><div id="ref-ldr" class="page hidden"><p>Load into a register from main memory</p><h3>Syntax</h3><p>LDR R<em>dest</em>, <em>memory</em></p><h3>Example</h3><code>LDR R0, 100</code><p>Loads the value at 100 into register 0</p><h3>Pseudocode</h3><code>regs[dest] ← main_mem[memory]</code><h3>Name</h3><p><em>L</em>oa<em>D</em> <em>R</em>egister</p></div><div id="ref-str" class="page hidden"><p>Store a registers value in main memory</p><h3>Syntax</h3><p>STR R<em>source</em>, <em>memory</em></p><h3>Example</h3><code>STR R0, 100</code><p>Store the value of register 0 into memory position 100</p><h3>Pseudocode</h3><code>main_mem[memory] ← regs[source]</code><h3>Name</h3><p><em>S</em><em>T</em>o<em>R</em>e</p></div><div id="ref-mov" class="page hidden"><p>Move a register value or a number into a register</p><h3>Syntax</h3><p>MOV R<em>dest</em>, R<em>source</em></p><p>MOV R<em>dest</em>, #<em>number</em></p><h3>Example</h3><code>MOV R0, #10</code><p>Put the value 10 in register 0</p><code>MOV R0, R1</code><p>Put the value of register 1 in register 0</p><h3>Pseudocode</h3><p>When given a register</p><code>regs[dest] ← regs[source]</code><p>When given a number</p><code>regs[dest] ← number</code><h3>Name</h3><p><em>M</em><em>O</em><em>V</em>e</p></div><div id="ref-add" class="page hidden"><p>Add a register or number to a register storing the result</p><h3>Syntax</h3><p>ADD R<em>dest</em>, R<em>source</em>, R<em>other</em></p><p>ADD R<em>dest</em>, R<em>source</em>, #<em>number</em></p><h3>Example</h3><code>ADD R0, R1, R2</code><p>Add the value of register 2 to that of register 1 storing the result in register 0</p><code>ADD R0, R1, #100</code><p>Add 100 to the value of register 1 storing the result in register 0</p><h3>Pseudocode</h3><p>When given a register</p><code>regs[dest] ← regs[source] + regs[other]</code><p>When given a number</p><code>regs[dest] ← regs[source] + number</code><h3>Name</h3><p><em>A</em><em>D</em><em>D</em></p></div><div id="ref-sub" class="page hidden"><p>Subtract a register or number from a register storing the result</p><h3>Syntax</h3><p>SUB R<em>dest</em>, R<em>source</em>, R<em>other</em></p><p>SUB R<em>dest</em>, R<em>source</em>, #<em>number</em></p><h3>Example</h3><code>SUB R0, R1, R2</code><p>Subtract the value of register 2 from that of register 1 storing the result in register 0</p><code>ADD R0, R1, #100</code><p>Subtract 100 from the value of register 1 storing the result in register 0</p><h3>Pseudocode</h3><p>When given a register</p><code>regs[dest] ← regs[source] - regs[other]</code><p>When given a number</p><code>regs[dest] ← regs[source] - number</code><h3>Name</h3><p><em>S</em><em>U</em><em>B</em>tract</p></div><div id="ref-cmp" class="page hidden"><p>Compare a register to another register or number, only useful when followed by a conditional branch</p><h3>Syntax</h3><p>CMP R<em>val</em>, R<em>other</em></p><p>CMP R<em>val</em>, #<em>number</em></p><h3>Example</h3><code>CMP R0, R1</code><p>Compare the values of register 0 &amp; register 1</p><code>ADD R0, #100</code><p>Compare register 0s value to 100</p><h3>Pseudocode</h3><p>When given a register</p><pre><code>IF regs[val] = regs[other] THEN
  flag ← "equal"
ELSE IF regs[val] &lt; regs[other] THEN
  flag ← "less"
ELSE
  flag ← "greater"
END IF</code></pre><p>When given a number</p><pre><code>IF regs[val] = number THEN
  flag ← "equal"
ELSE IF regs[val] &lt; number THEN
  flag ← "less"
ELSE
  flag ← "greater"
END IF</code></pre><h3>Name</h3><p><em>C</em>o<em>M</em><em>P</em>are</p></div><div id="ref-branching-overview" class="page hidden"><p>Branching is an important low level construct but is rarely seen in higher level languages</p><p>Those that do include branching generally refer to it as 'GOTOs', as is the case in BASIC, C/C++ &amp; C#</p><p>Most languages omit branching because they build more powerful concepts atop it such as subroutines, if statements and loops</p></div><div id="ref-b" class="page hidden"><p>Unconditional branch or 'jump'</p><h3>Syntax</h3><p>B <em>label</em></p><h3>Example</h3><code>B marker</code><p>Moves execution to the line labled 'marker'</p><h3>Pseudocode</h3><p>The closest construct is a subroutine call</p><code>marker()</code><p>But that would imply execution returns it's original position, this is not the case.</p><h3>Name</h3><p><em>B</em>ranch</p></div><div id="ref-beq" class="page hidden"><p>Branch if the last CMP was equal</p><h3>Syntax</h3><p>BEQ <em>label</em></p><h3>Example</h3><code>BEQ marker</code><p>Conditionaly moves execution to the line labled 'marker'</p><h3>Pseudocode</h3><pre><code>IF flag = "equal" THEN
  marker()
END IF</code></pre><p>Unfortunatly this doesn't exactly represent BEQ</p><h3>Name</h3><p><em>B</em>ranch <em>E</em><em>Q</em>ual</p></div><div id="ref-bne" class="page hidden"><p>Branch if the last CMP was not equal</p><h3>Syntax</h3><p>BNE <em>label</em></p><h3>Example</h3><code>BNE marker</code><p>Conditionaly moves execution to the line labled 'marker'</p><h3>Pseudocode</h3><pre><code>IF NOT flag = "equal" THEN
  marker()
END IF</code></pre><p>Unfortunatly this doesn't exactly represent BNE</p><h3>Name</h3><p><em>B</em>ranch <em>N</em>ot <em>E</em>qual</p></div><div id="ref-bgt" class="page hidden"><p>Branch if the last CMP result was greater</p><h3>Syntax</h3><p>BGT <em>label</em></p><h3>Example</h3><code>BGT marker</code><p>Conditionaly moves execution to the line labled 'marker'</p><h3>Pseudocode</h3><pre><code>IF flag = "greater" THEN
  marker()
END IF</code></pre><p>Unfortunatly this doesn't exactly represent BGT</p><h3>Name</h3><p><em>B</em>ranch <em>G</em>reater <em>T</em>han</p></div><div id="ref-blt" class="page hidden"><p>Branch if the last CMP result was less</p><h3>Syntax</h3><p>BLT <em>label</em></p><h3>Example</h3><code>BLT marker</code><p>Conditionaly moves execution to the line labled 'marker'</p><h3>Pseudocode</h3><pre><code>IF flag = "less" THEN
  marker()
END IF</code></pre><p>Unfortunatly this doesn't exactly represent BLT</p><h3>Name</h3><p><em>B</em>ranch <em>L</em>ess <em>T</em>han</p></div><div id="ref-bitwise-overview" class="page hidden"><!-- TODO: Improve --><p>Bitwise operations consider the binary representation of integers</p><p>It's important not to confuse these with their boolean equivalents as they can behave quite differently</p><p>Even in languages with a boolean type they are really integers where 0 is false and <strong>any</strong> other value is true, thus 'a AND b' checks that neither a or b equal 0</p><p>However bitwise operators work on the bits that make up the integer rather than it's value, for example a logical AND between 1 &amp; 8 would be true as neither are zero but a bitwise AND between them is 0</p><p>Shifts move bits around, so shifting 0010 (2) to the left by two is 1000 (8) whereas shifting to right would be 0000 (0)</p><p>It's important to remember that even though bitwise and shift operations work with integers they do not work on them as numbers</p></div><div id="ref-and" class="page hidden"><p>Bitwise AND between two values</p><p>That is to say it performs a logical AND between each bit, so the AND of 2 (0010) &amp; 6 (0110) is 2 (0010)</p><h3>Syntax</h3><p>AND R<em>dest</em>, R<em>source</em>, R<em>other</em></p><p>AND R<em>dest</em>, R<em>source</em>, #<em>number</em></p><h3>Example</h3><code>AND R0, R1, R2</code><p>Performs a logical AND between register 1 and register 2 placing the result in register 0</p><h3>Pseudocode</h3><p>The AND operator is not bitwise because it produces a boolean not integer result</p><p>When given a register</p><code>regs[dest] ← regs[source] AND regs[other]</code><p>When given a number</p><code>regs[dest] ← regs[source] AND number</code><h3>Name</h3><p><em>A</em><em>N</em><em>D</em></p></div><div id="ref-orr" class="page hidden"><p>Bitwise OR between two values</p><p>That is to say it performs a logical OR between each bit, so the OR of 2 (0010) &amp; 6 (0110) is 6 (0110)</p><h3>Syntax</h3><p>ORR R<em>dest</em>, R<em>source</em>, R<em>other</em></p><p>ORR R<em>dest</em>, R<em>source</em>, #<em>number</em></p><h3>Example</h3><code>ORR R0, R1, R2</code><p>Performs a logical OR between register 1 and register 2 placing the result in register 0</p><h3>Pseudocode</h3><p>The OR operator is not bitwise because it produces a boolean not integer result</p><p>When given a register</p><code>regs[dest] ← regs[source] OR regs[other]</code><p>When given a number</p><code>regs[dest] ← regs[source] OR number</code><h3>Name</h3><p><em>O</em><em>R</em>(<em>R</em>)</p><p>Additional R is used to maintain consistant three letter commands</p></div><div id="ref-eor" class="page hidden"><p>Bitwise exclusive OR between two values</p><p>That is to say it performs a logical exclusive OR between each bit, so the EOR of 2 (0010) &amp; 6 (0110) is 4 (0100)</p><p>As exclusive OR only allows one input to be true in the style of (a or b) and not (a and b)</p><h3>Syntax</h3><p>EOR R<em>dest</em>, R<em>source</em>, R<em>other</em></p><p>EOR R<em>dest</em>, R<em>source</em>, #<em>number</em></p><h3>Example</h3><code>EOR R0, R1, R2</code><p>Performs a logical exclusive OR (XOR) between register 1 and register 2 placing the result in register 0</p><h3>Pseudocode</h3><p>Neither OR or AND operators are bitwise because they are logical so produce a boolean result rather than integer</p><p>When given a register</p><code>regs[dest] ← (regs[source] OR regs[other]) AND NOT (regs[source] AND regs[other])</code><p>When given a number</p><code>regs[dest] ← (regs[source] OR number) AND NOT (regs[source] AND number)</code><h3>Name</h3><p><em>E</em>xclusive <em>O</em><em>R</em></p></div><div id="ref-mvn" class="page hidden"><p>Move a register value or a number into a register having inverted it</p><h3>Syntax</h3><p>MVN R<em>dest</em>, R<em>source</em></p><p>MVN R<em>dest</em>, #<em>number</em></p><h3>Example</h3><code>MVN R0, #10</code><p>Put the value 10 (1010) in register 0 having inverted it to 5 (0101)</p><code>MVN R0, R1</code><p>Put the value of register 1 in register 0 having inverted it</p><h3>Pseudocode</h3><p>When given a register</p><code>regs[dest] ← NOT regs[source]</code><p>When given a number</p><code>regs[dest] ← NOT number</code><p>NOT is generally logical not bitwise so this sample will not show the same result as MVN</p><h3>Name</h3><p><em>M</em>o<em>V</em>e <em>N</em>OT</p></div><div id="ref-lsl" class="page hidden"><!-- TODO: Improve --><p>Perform a left shift</p><p>Moves the binary representation a specified number of bits to the left, padding with 0s on the right</p><p>Any bits overflowing the far left are discarded</p><h3>Syntax</h3><p>LSL R<em>dest</em>, R<em>source</em>, R<em>by</em></p><p>LSL R<em>dest</em>, R<em>source</em>, #<em>by</em></p><h3>Example</h3><code>LSL R1, R0, #1</code><p>Shift register 0 by 1 place to the left placing the result in register 1</p><code>LSL R2, R1, R0</code><p>Shift register 1 to the left by register 0s value placing the result in register 2</p><h3>Pseudocode</h3><p>Shifts are not generally used pseudocode but assuming it was it's use would be similar to any other operator</p><p>When given a register</p><code>regs[dest] ← regs[source] LSL regs[by]</code><p>When given a number</p><code>regs[dest] ← regs[source] LSL by</code><h3>Name</h3><p><em>L</em>ogical <em>S</em>hift <em>L</em>eft</p></div><div id="ref-lsr" class="page hidden"><!-- TODO: Improve --><p>Perform a right shift</p><p>Moves the binary representation a specified number of bits to the right, padding with 0s on the left</p><p>Any bits overflowing the far right are discarded</p><h3>Syntax</h3><p>LSR R<em>dest</em>, R<em>source</em>, R<em>by</em></p><p>LSR R<em>dest</em>, R<em>source</em>, #<em>by</em></p><h3>Example</h3><code>LSR R1, R0, #1</code><p>Shift register 0 by 1 place to the right placing the result in register 1</p><code>LSR R2, R1, R0</code><p>Shift register 1 to the right by register 0s value placing the result in register 2</p><h3>Pseudocode</h3><p>Shifts are not generally used pseudocode but assuming it was it's use would be similar to any other operator</p><p>When given a register</p><code>regs[dest] ← regs[source] LSR regs[by]</code><p>When given a number</p><code>regs[dest] ← regs[source] LSR by</code><h3>Name</h3><p><em>L</em>ogical <em>S</em>hift <em>R</em>ight</p></div><div id="ref-halt" class="page hidden"><p>End execution</p><h3>Syntax</h3><p>HALT</p><h3>Example</h3><code>HALT</code><p>Stops all execution</p><h3>Pseudocode</h3><p>The closest construct is returning from a procedure</p><code>RETURN</code><p>But that would imply execution returns to some other place rather than stopping altogether</p><h3>Name</h3><p><em>H</em><em>A</em><em>L</em><em>T</em></p></div></div></main><footer><a href="https://zanderbrown.github.io">&copy; Zander Brown</a> <a href="https://github.com/ZanderBrown/aqabler">GitHub Repo</a></footer></body></html>